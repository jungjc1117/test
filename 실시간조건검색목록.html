<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>실시간 시세 수신 (Kiwoom Mock API)</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 20px;
        background-color: #f4f4f4;
        color: #333;
      }
      .container {
        max-width: 800px;
        margin: auto;
        background: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
      }
      h1 {
        text-align: center;
        color: #4caf50;
      }
      #message-container {
        border: 1px solid #ddd;
        padding: 10px;
        height: 500px;
        overflow-y: scroll;
        background-color: #fafafa;
        border-radius: 4px;
      }
      .message {
        background-color: #e9e9e9;
        padding: 8px;
        margin-bottom: 5px;
        border-radius: 4px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>실시간 시세 수신 (Kiwoom Mock API)</h1>
      <div id="message-container"></div>
    </div>

    <script>
      const SOCKET_URL = "wss://mockapi.kiwoom.com:10000/api/dostk/websocket";
      const ACCESS_PARAMS = {
        grant_type: "client_credentials",
        appkey: "oJ5S3eaEUVsSaxPX7vkiOPjOI9_yvkFGm3lwAkd_fAg",
        secretkey: "lA1nom_3Ql1TX1rUpppvwhRJBuEQ44cECAYn7lCGgps",
      };

      const messageContainer = document.getElementById("message-container");

      let accessToken = null;
      let websocket = null;
      let currentSeq = null; // To store the sequence number from CNSRLST

      // 접근 토큰 발급 함수
      async function getAccessToken() {
        const url = "https://mockapi.kiwoom.com/oauth2/token";
        const headers = {
          "Content-Type": "application/json;charset=UTF-8",
        };

        try {
          logMessage("접근 토큰 발급 요청 중...");
          const response = await fetch(url, {
            method: "POST",
            headers: headers,
            body: JSON.stringify(ACCESS_PARAMS),
          });

          if (response.ok) {
            const data = await response.json();
            logMessage("접근 토큰 발급 성공.");
            return data.token;
          } else {
            logMessage(
              `Token Error: ${response.status} ${response.statusText}`
            );
            return null;
          }
        } catch (error) {
          logMessage("Fetch Error:", error);
          return null;
        }
      }

      // WebSocket 연결 및 메시지 처리
      async function connectWebSocket() {
        accessToken = await getAccessToken();

        if (!accessToken) {
          logMessage("접근 토큰 발급에 실패했습니다. 연결을 종료합니다.");
          return;
        }

        logMessage("WebSocket 서버에 연결 중...");
        websocket = new WebSocket(SOCKET_URL);

        websocket.onopen = (event) => {
          logMessage("WebSocket 서버 연결 성공.");
          // 로그인 패킷 전송
          const loginPacket = {
            trnm: "LOGIN",
            token: accessToken,
          };
          websocket.send(JSON.stringify(loginPacket));
          logMessage("로그인 패킷 전송 완료.");
        };

        websocket.onmessage = (event) => {
          const response = JSON.parse(event.data);
          const trnm = response.trnm;

          if (trnm === "LOGIN") {
            if (response.return_code !== 0) {
              logMessage(`로그인 실패: ${response.return_msg}`);
              websocket.close();
            } else {
              logMessage("로그인 성공. 조건검색 목록 조회 요청.");
              // 로그인 성공 후 CNSRLST 요청
              const cnsrlstPacket = {
                trnm: "CNSRLST",
              };
              websocket.send(JSON.stringify(cnsrlstPacket));
            }
          } else if (trnm === "CNSRLST") {
            // 조건검색 목록 조회 응답
            logMessage("조건검색 목록 응답 수신: " + JSON.stringify(response));
            if (response.data && response.data.length > 0) {
              // 첫 번째 검색식의 'seq' 값을 가져옴
              currentSeq = response.data[0][0]; // Store the seq
              logMessage(`첫 번째 조건검색식 seq: ${currentSeq}`);

              // CNSRREQ 요청을 보냄
              const cnsrreqPacket = {
                trnm: "CNSRREQ",
                seq: currentSeq, // Use the retrieved seq
                search_type: "0",
                stex_tp: "K",
                cont_yn: "Y", // Set to 'Y' for continuous data
                next_key: "",
              };
              websocket.send(JSON.stringify(cnsrreqPacket));
              logMessage("실시간 항목 등록 패킷 전송 완료.");
            } else {
              logMessage(
                "조건검색 목록이 비어 있습니다. CNSRREQ를 보낼 수 없습니다."
              );
            }
          } else if (trnm === "PING") {
            console.log("PING 응답 수신");
            websocket.send(JSON.stringify(response)); // 그대로 다시 전송
          } else {
            // For other messages like CNSRREQ responses
            logMessage(JSON.stringify(response, null, 2));
          }
        };

        websocket.onclose = (event) => {
          logMessage(
            `서버 연결이 종료되었습니다. 코드: ${event.code}, 이유: ${event.reason}`
          );
        };

        websocket.onerror = (error) => {
          console.error("WebSocket Error:", error);
          logMessage("WebSocket 에러가 발생했습니다.");
        };
      }

      function logMessage(message) {
        const pre = document.createElement("pre");
        pre.className = "message";
        pre.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
        messageContainer.prepend(pre); // 최신 메시지를 상단에 추가
      }

      window.onload = connectWebSocket;
    </script>
  </body>
</html>
